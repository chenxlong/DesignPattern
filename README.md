# DesignPattern(设计模式)
本仓库是C++的设计模式应用范例。仓库中代码代码采用QtCreator（MinGW）编译。  UML绘制使用StarUML软件。  

------------------------------------------------------------------------------------------------
## 设计模式分为三大类：
* 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。  
* 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。  
* 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。  
  其他模式：并发型模式和线程池模式。  

### 简单工厂模式（SimpleFactory）  
简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。  
简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。  
简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。  

### 工厂方法模式（Factory Method）
定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。  

### 抽象工厂（Abstract Factory）
提供一个创建一系列相关或相互依赖的对象接口，而无需指定他们具体的类。

### 单例模式（Singleton）
保证一个类仅有一个实例，并提供一个访问它的全局访问点。

### 建造者模式（Builder）
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

### 原型模式（Prototype）
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
其实就是从一个对象再创建另外一个可定制的对象，而不需要知道任何创建细节。

### 适配器模式（Adapter）
将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

### 装饰器模式（Decorator）
动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。

### 代理模式（Proxy）
为其他对象提供一种代理以控制对这个对象的访问。代理就是真实对象的代表。

### 外观模式（Facade）
为子系统中的一组接口提供一个一致的界面。此模式定义了一个高层接口，这个接口使得子系统更容易使用。

### 桥接模式（Bridge）
将抽象部分与它的实现部分分离，使他们都可以独立变化。

### 组合模式（Composite）
将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的访问具有一致性。

### 享元模式（Flyweight）
运用共享技术有效的支持大量细粒度的对象。

### 策略模式（Strategy）
它定义了算法家族，分别封装起来，让他们之间可以相互替换。此模式让算法的变化，不会影响到使用算法的客户。

### 模板方法模式（TemplateMethod）
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

### 观察者模式（Observer）
定义一种一对多的依赖关系，让多个观察者对象同事监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能自动更新自己。

### 迭代器模式（Iterator）
提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。

### 责任链模式（Chain of Responsibility）
使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将多个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

### 命令模式（Command）
将一个请求封装为一个对象，从而使你可用不同的请求对客户端进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

### 备忘录模式（Memento）
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

### 状态模式（State）
当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类。

### 访问者模式（Visitor）
表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

### 中介者模式（Mediator）
用一个中介对象封装一系列的对象交互。中介者使各对象不需要显示的相互引用，从而使其耦合松散，而且可以独立的改变他们的交互。

### 解释器模式（interpreter）
给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

### 并发型模式
反应器模式（Reactor）：一种事件驱动架构。

### 线程池模式（ThreadPool）
假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。
如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。  

------------------------------------------------------------------------------------------------
## 类之间关系表现
* 继承：继承父类，扩展子类（符号：一条带空心三角箭头的实线，从子类指向父类，或者子接口指向父接口。）
* 实现：类和接口之间关系（符号：实现用一条带空心三角箭头的虚线表示，从类指向实现的接口）
* 依赖：A类使用了B类的一部分属性或方法，不会主动改变B类内容。类A的某个方法里使用了类B的实例作为局部变量，类A调用了类B的静态方法（符号：带箭头虚线表示）
* 关联关系：一个类作为另一个类方法的参数（符号：带箭头实线表示）
* 聚合关系：类B包含类A的指针（符号：空心菱形加实线箭头）
* 组合关系：类B包含类A的对象（符号：实心菱形加实线箭头）

>依赖关系是一种使用关系，他是对象间耦合性最弱的一种关联关系。  
>关联关系是对象间的一种引用关系，分为一般关联关系，聚合关联关系，组合关联关系。  
>聚合关联关系是整体和部分之间的关系，部分可以脱离整体独立存在。  
>组合关系是更强的关联关系，是整体和部分的关系，部分不能脱离整体存在。  
>关系的强弱：组合>聚合>关联>依赖。也就是说是关联关系也一定是依赖关系。  

关联和依赖的区别：  
>关联关系强、长期  
>关联关系是通过属性来实现；依赖关联是通过方法形参或者局部变量实现  

关联、组合/聚合的异同：  
>相同：都是关联，都是做类的属性  
>不同点：组合 /聚合表示的是整体和部分的关系，关联可以表示所有关系  

组合和聚合的异同：  
>相同：都是关联的特例，都是表示的整体和部分的关系  
>不同点：整体部分的生命周期是否相同，组合更强  
